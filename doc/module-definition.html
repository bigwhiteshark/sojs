
<!doctype html>
<html>
<head>
<meta http-equiv="Pragma" content="no-cache"/>
<meta charset="utf-8"/>
<title>模块定义 - so.js 手册与文档</title>
<link rel="stylesheet" href="assets/css/api.css"/>
</head>
<body>
<div id="container">

  <header>
    <h1>so.js 手册与文档</h1>
    <div id="gtoc">
      <p><a href="../../">首页</a> | <a href="index.html">索引</a></p>
    </div>
    <hr/>
  </header>

  <div id="toc">
    <h2 id="table_of_Contents">目录</h2>

    <ul>
      <li><a href="#module-definition">模块定义</a>
        <ul>
          <li><a href="#define">define</a>
            <ul>
              <li><a href="#define-id">id</a></li>
              <li><a href="#define-dependencies">dependencies</a></li>
              <li><a href="#define-factory">factory</a></li>
            </ul>
          </li>
          <li><a href="#exports">exports</a></li>
          <li><a href="#require">require</a>
            <ul>
              <li><a href="#require-id">require(id)</a></li>
              <li><a href="#require-async">require(id, callback?)</a></li>
            </ul>
          </li>
          <li><a href="#module">module</a>
            <ul>
              <li><a href="#module-id">module.id</a></li>
              <li><a href="#module-dependencies">module.dependencies</a></li>
              <li><a href="#module-exports">module.exports</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <hr/>
  </div>


  <h2 id="module-definition">模块定义</h2>

  <p>
    在 sojs 中，所有 JavaScript 文件都应该用模块的形式来书写，并且一个文件只包含一个模块。
  </p>


  <h3 id="define">define</h3>

  <p>
    使用全局函数 <code>define</code> 来定义模块：
  </p>

<pre>
define (factory);

define(id?, dependencies?, factory);
</pre>


  <h4 id="define-id">id</h4>

  <p>
    当前模块的唯一标识。该参数可选。如果没有指定，默认为模块所在文件的访问路径。如果指定的话，
    必须是顶级或绝对标识（不能是相对标识）。
  </p>


  <h4 id="define-dependencies">dependencies</h4>

  <p>
    当前模块所依赖的模块，是一个由模块标识组成的数组。该参数可选。如果没有指定，模块加载器会从
    <code>factory.toString()</code> 中解析出该数组。
  </p>


  <p>
    ** 注意：强烈推荐不要设定 <code>id</code> 和 <code>dependencies</code> 参数。
    在开发阶段，模块加载器会自动获取这两个参数。部署上线时，则可以通过优化工具来提取这两个参数。
  </p>


  <h4 id="define-factory">factory</h4>

  <p>
    模块的工厂函数。模块初始化时，会调用且仅调用一次该工厂函数。<code>factory</code> 可以是函数，
    也可以是对象、字符串等任意值，这时 <code>module.exports</code> 会直接设置为
    <code>factory</code> 值。
  </p>

  <p>
    <code>factory</code> 函数在调用时，会始终传入三个参数：
    <code>require</code>、<code>exports</code> 和 <code>module</code>，
    这三个参数在所有模块代码里可用。
  </p>

<pre>
define(function(require, exports, module) {

  // The module code goes here
  
});

define({ name: "bigwhiteshark" });

define('I am sojs that a tiny javascript on-demand module loader.');
</pre>


  <h3 id="exports">exports</h3>

  <p>
    <code>exports</code> 用来向外提供模块的 API.
  </p>

<pre>
define(function(require, exports) {
  // snip...
  exports.foo = 'bar';
  exports.doSomething = function() {};
});

define(function(require,exports,module){
        function Computer(){
        }
        var p = Computer.prototype;
        p.add = function(a,b){
            return a+b
        }
        module.exports = Computer
});
</pre>

  <p>
    除了给 <code>exports</code> 对象增加成员，还可以使用 <code>return</code>
    直接向外提供 API.
  </p>

<pre>
define(function(require, exports) {
  // snip...
  return {
    foo: 'bar'，
    doSomething: function() {};
  };
});
</pre>

  <p>
    如果 <code>return</code> 语句是模块中的唯一代码，可简化为：
  </p>

<pre>
define({
  foo: 'bar'，
  doSomething: function() {};
});
</pre>

  <p>
    上面这种格式特别适合定义 JSON 数据。
  </p>

  <p>
    ** 注意：下面这种写法是错误的！
  </p>

<pre class="wrong">
define(function(require, exports) {
  // snip...
  exports = { // 错误!
    foo: 'bar'，
    doSomething: function() {};
  };
});
</pre>

  <p>
    模块加载器不能获取到新赋给 <code>exports</code> 变量的值。
      请使用 <code>return</code> 或 <code>module.exports</code> 。
  </p>


  <h3 id="require">require</h3>

  <p>
    <code>require</code> 函数用来访问其他模块提供的 API.
  </p>

<pre>
define(function(require) {
  var a = require('./a');
  a.doSomething();
});
</pre>

  <p>
    它接受 <a href="module-identifier.html">模块标识</a> 作为唯一参数。
  </p>

  <p>
    请牢记，为了使静态分析能成功获取到模块依赖信息，在书写模块时，需要遵循一些简单的
    <a href="rules.html">规则</a>。
  </p>

  <h4 id="require-id">require(id)</h4>

  <p>
    接受 id 模块标识 作为唯一参数，用来获取其他模块提供的接口。
  </p>

<pre>
//引用printer模块
var printer = require('mods/printer');
//调用模块 printer 的方法
printer.echo();

define(function(require, exports) {

  // 获取模块 a 的接口
  var a = require('./a');

  // 调用模块 a 的方法
  a.doSomething();

});
</pre>

  <h4 id="require-async">require(id, callback?)</h4>

  <p>
    该方法可用来异步加载模块，并在加载完成后执行回调函数。
  </p>

<pre>
define(function(require, exports, module) {
  // 加载一个模块
  require('./b', function(b) {
    b.doSomething();
  });
  
  // 加载多个模块
  require(['./c', './d'], function(c, d) {
    // do something
  });
});
</pre>

  <h3 id="module">module</h3>

  <p>
    <code>module</code> 参数存储模块的元信息。拥有以下成员：
  </p>

  <h4 id="module-id">module.id</h4>

  <p>
    当前模块的唯一标识。
    <code>require(module.id)</code> 必然返回此模块的 <code>exports</code> 。
  </p>

<pre>
define(function(require, exports, module) {
  console.log(module.id); // http://path/to/this/file.js
  console.log(require(module.id) === exports); // true
});
</pre>


  <h4 id="module-dependencies">module.dependencies</h4>

  <p>
    <code>module.dependencies</code> 是一个数组，表示当前模块的依赖列表。
  </p>

  <p>
    该数组只读：模块加载完成后，修改该数组不会有任何效果。
  </p>


  <h4 id="module-exports">module.exports</h4>

  <p>
    <code>exports</code> 对象由模块系统创建，这不能满足开发者的所有需求，
    有时候会希望 <code>exports</code> 是某个类的实例。
    这时可用 <code>module.exports</code> 来实现：
  </p>

<pre>
define(function(require, exports, module) {
  console.log(module.exports === exports); // true
  module.exports = new SomeClass();
  console.log(module.exports === exports); // false
});
</pre>
  <p>
    注意，对 <code>module.exports</code> 的赋值需要同步执行，它不能放在回调函数里。
      下面这样是不行的：
  </p>

  <p>x.js:</p>

<pre>
define(function(require, exports, module) {
  setTimeout(function() {
    module.exports = { a: "hello" };
  }, 0);
});
</pre>

  <p>y.js:</p>

<pre>
define(function(require, exports, module) {
  var x = require('./x');
  console.log(x.a); // undefined
});
</pre>

</div>
</body>
</html>
